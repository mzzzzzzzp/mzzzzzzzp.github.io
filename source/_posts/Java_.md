---
title: Java
date: 2019-4-12 15:02:22
categories: Java
---
---
#### JDK和JRE
- JDK（java Development Kit），Java开发工具包，提供了Java的开发环境和运行环境，包含Java虚拟机，Java基础类库，JRE，编译器Javac等。
- JRE（Java Runtime Environment），Java运行环境，只需要运行Java程序时，安装JRE就可以了。

![JDK&JRE](https://github.com/mzzzzzzzp/mzzzzzzzp.github.io/blob/master/images/JDK%E5%92%8CJRE.png?raw=true)
#### 编译
编译的主要的目的是将便于人编写、阅读、维护的**高级语言**所写作的源代码程序，**翻译**为计算机能解读、运行的**低级语言**的程序，也就是可执行文件。  
Java语言的源文件是一个Java文件，要将一个Java文件，转换为二进制文件一共要经过两个步骤。
- 首先经过前端编译器（主要是JavaC），将Java文件编译成中间代码，这种中间代码就是Class文件，即字节码文件(xx.Javac)。
- 然后，在经过后端编译器，将Class字节码文件，编译成机器语言。

#### 标识符
是指程序中，定义的内容，比如类名，方法名，变量名等
##### 命名规范
    类名规范：大驼峰式，首字母大写，后面每个单词首字母大写。
    方法名规范：小驼峰式，首字母小写，后每个单词首字母大写。
    变量名规范：小驼峰式 。
  
#### 常量
| 类型 | 含义 |
| :-: | :-: |
| 整数常量 | 所有整数 |
| 小数常量 | 所有小数 |
| 字符常量 | 单引号引用，只能写一个字符 |
| 字符串常量 | 双引号引用，可以写多个字符 |
| 布尔常量 | 只有两个值，true/false |
| 空常量 | 只有一个值，null |

#### 数据类型
##### 基本数据类型
四类八种：
    整数型 byte，short，int，long
    浮点型 float，double
    字符型 char
    布尔型 boolean
    
| 数据类型 | 关键字 | 内存占用 | 取值范围 |    
| :-: | :-: | :-: | :-: |  
| 字节型 | byte | 1个字节 | -128~127 |  
| 短整型 | short | 2个字节 | -32768~32767 |    
| 整形 | int | 4个字节 | -2^31~2^32-1 |    
| 长整型 | long | 8个字节 | -2^63~2^64-1 |    
| 单精度浮点数 | float | 4个字节 | 1.4013E-45~3.4028E+38 |    
| 双精度浮点数 | double | 8个字节 | 4.9E-324~1.7977E+308 |    
| 字符型 | char | 2个字节 | 0~65535 |    
| 布尔型 | boolean | 1个字节 | true/false |  
  
##### 引用数据类型     
字符串，数组，类，接口，Lambda，等等。

#### ASCII编码(American Standard Code for Information Interchange，美国标准代码交换表)
| 字符 | ASCII值 |
| :-: | :-: |
| 0 | 48 |
| A | 65 |
| a | 97 |


#### 方法重载的几种情况
- 参数个数不同
- 参数类型不同
- 参数的多类型顺序不同  

#### 数组
- 动态初始化（指定长度）：创建数组时，直接指定数组当中的数据元素个数；
- 静态初始化（指定内容）：创建时不指定数据个数是多少，直接指定内容。

#### 局部变量和成员变量
- 定义的位置不一样

| 局部变量 | 方法内部 |
| :-: | :-: |
| 成员变量 | 类中，方法外 |

- 作用范围不一样

| 局部变量 | 该方法中可以使用 |
| :-: | :-: |
| 成员变量 | 整个类通用 |

- 默认值不一样

| 局部变量 | 无默认值，需赋值初始化 |
| :-: | :-: |
| 成员变量 | 若不初始化，有默认值 |

- 内存位置不同

| 局部变量 | 位于栈内存 |
| :-: | :-: |
| 成员变量 | 位于堆内存 |

- 声明周期不同

| 局部变量 | 随方法进栈而产生，方法出栈就消失 |
| :-: | :-: |
| 成员变量 | 随对象创建而产生，对象被垃圾回收就消失 |


#### 一个标准的类

- 所有成员变量都为private
- 所有成员变量都有Getter、Setter方法
- 有无参构造函数
- 有全参构造函数

#### Scanner类的使用

- 导入包
- 创建类的对象
        Scanner sca = new Scanner(System.in)
- 获取输入的数据
        int a = sca.nextInt()

#### Random类的使用

与上面Scanner类似。

#### 字符串String

- 特点
    字符串的内容不能改变；
    可以共享使用，线程安全；
    效果相当于char[]字符数组，底层原理是byte[]字节数组。

- new String[]创建的字符串存在堆中，但不在常量池中。

- 直接创建的字符串位于常量池中，可共享，eg： String str1 = "abc";  String str2 = "abc";  str1和str2共享"abc".

#### 数学工具类Math

| abs(double) | 取绝对值 |
| :-: | :-: |
| ceil(double num) | 向上取整 |
| floor(double num) | 向下取整 |
| round(double num) | 四舍五入 |

#### 重载和重写
- 重载
方法名称一样，但参数列表不一样。
- 重写
发生在父子类中，名称和参数列表都一样。
子类重写的方法前面添加 @Override 注解检查重写是否正确。

#### super关键字

- 在子类中，访问父类的成员变量；
- 访问父类的成员方法；
- 访问父类的构造方法。

#### this关键字

- 在本类成员方法中，访问本类的成员变量；
- 在本类的成员方法中，访问本类另一个成员方法；
- 在本类的构造方法中，访问本类的另一个构造方法。

#### 接口Interface
一个类只能继承一个父类，但可以实现多个接口；接口之间可以多继承。
- 没有静态代码块，没有构造方法；
- 一个类可以实现多个接口；
- 多个类中有重复的抽象方法，只需重写一个；默认方法重复则需要重写。
- 一个类继承父类当中的方法，如果和接口中的默认方法产生冲突，优先调用父类方法。

##### 成员变量，其实是常量
   常量必须赋值初始化，之后值不能改变；
   常量名称完全大写，用下划线分隔。

##### 抽象方法
   实现类必须覆盖重写接口的所有抽象方法，除非实现类是抽象类。

##### 静态方法
   通过接口名称进行调用，不能通过类对象调用。

##### 私有方法
   只有接口才能调用。
    
#### 多态
简单来说，指相同的消息给予不同的对象会引发不同的动作。具体是指同一个接口，使用不同的实例而执行不同操作。
代码当中体现多态性的必要条件：
- 继承关系
- 子类重写父类方法
- 父类引用指向子类对象：
eg：父类名称 对象名 = new 子类名称()；
eg：接口名称 对象名 = new 实现名称()；

##### 结果
调用同名的非静态方法时，会调用子类的方法；调用成员变量和其他都是获取父类的结果。

#### final关键字

- 修饰基本类型，表示变量的数据不可改变；
- 修饰引用类型，表示变量的地址值不可改变。

#### 四种权限修饰符

|  | public | protected | default | private |
| :-: | :-: | :-: | :-: | :-: |
| 同一个类 | √ | √ | √ | √ |
| 同一个包 | √ | √ | √ | × |
| 不同包子类 | √ | √ | × | × |
| 不同包非子类 | √ | × | × | × |

#### 匿名对象
省略了对象的名称，eg：
     new 类名称();
匿名对象在调用方法时，只能调用一个方法。

#### ==和equals
##### ==
- 对于基本类型，比较**数值**。
- 对于引用类型，比较**地址值**。

##### equals

源码中其实是根据 == 来判断两个对象的地址值是否相等。
        
    public boolean equals(Object obj){
        return (this == obj);
    }
    
#### Format类   
是一个抽象类，下面有
- ParsePosition
- FieldPosition
- NumberFormat
- DateFormat
- MessageFormat
几个抽象的子类。

##### DateFormat类
DataFormat是一个抽象类，无法直接实例化创建对象使用，可以使用子类。
一般用SimpleDateFormat子类来格式化和解析时间字符串。

#### Calender类：日历类

使用的使用查API文档。

#### 包装类
包装类便于对基本数据类型进行操作。

#### 集合

集合中只能存放引用类型数据，不能存放基本类型数据（非要存放的话需要对数据自动或手动装箱）。
本质上存放的是对象的引用，实际内容在堆或方法区当中，因为栈上的数据随时都可能被收回。
**Collection集合——单列集合**
**Map集合——双列集合**

##### 集合与数组
都是**容器**，区别如下：

|  | 长度 | 存储 |
| :-: | :-: | :-: |
| 集合 | 可变 | 对象 |
| 数组 | 固定 | 对象、基本数据类型 |
##### **Collection集合总览**
**下面的集合都是单列集合**
![集合](https://github.com/mzzzzzzzp/mzzzzzzzp.github.io/blob/master/images/%E9%9B%86%E5%90%88.png?raw=true)

###### List集合

- 集合是有序的；
- 可以有重复的数据；
- 有索引，可以使用for循环遍历。

###### ArrayList

- 底层是数组结构，查询快，增删慢；
- 增删的本质是调用arraycopy。

###### LinkedList
- 底层是一个链表结构：查询慢，增删快；
- 包含大量操作首位元素的方法。
需要使用LinkedList特有的方法，就不能使用多态来new。

###### Set集合

- 不允许存储重复的元素；
原理：存储数据时，会调用hashCode()和equals方法()，判断元素是否重复。
- 没有索引，不能用for循环遍历；
- 可以用while循环和增强for循环遍历。

###### HashSet
底层是HashMap，即哈希表存储数据，查询速度几乎为O(1)；
集合特点和Set相同。

**哈希表**
- 存储数据结构为哈希表，查询速度非常快。

- 哈希表 = 数组 + 链表/红黑树。
 
- 数组根据哈希值和数组长度取余后对元素分组；哈希冲突的值存放在链表中，当链表元素大于8个时用红黑树存储。

###### LinkedHashSet
是HashSet的子类，特点是有顺序的存放不重复的数据。底层是一个哈希表加上一个链表，链表用来存储数据的存放顺序。

##### Hash值
是一个十进制的整数，hashCode()底层为native方法，即调用了系统本地操作系统的方法。

##### Map集合

- 双列集合，一个元素包含两个值（键值对）；
- key、value的数据类型可以不相同；
- key不能重复，value可以重复；
- 每个key对应一个值。
- 常见方法
    put();
    get();
    remove();
    containKey();
    KeySet(); //把map中的所有Key取出来，存到一个Set集合中。这是遍历map集合的一种方式。
    entrySet(); //把多个entry对象取出存到Set集合，第二种遍历方法。

###### HashMap集合

- 底层是哈希表(数组+链表/红黑树)，查询速度非常快，接近0(1)；
- 无序的集合，存储元素和取出元素的顺序可能不一致。

###### LinkedHashMap集合

- 底层是哈希表 + 链表（保证迭代的顺序）；
- 有序的集合。

###### Hashtable集合

- 底层也是哈希表，但是线程安全，单线程，速度慢，不能存放null值和键；HashMap相反；
- Hashtable被HashMap取代，Vector被ArrayList取代；
- Hashtable的子类Properties和IO流相结合。

#### 迭代器Iterator
Iterator是一个接口，不能直接使用，需要接口的实例类对象。
Collection接口中iterator()方法返回的就是迭代器的实例类对象。

- Iterator it = coll.iterator();  获取迭代器的实例类对象，并且指针(索引)指向集合的-1索引。


##### 两个常用方法：

- boolean hasNext();
如果集合中还有元素，则返回true。
- E next();
返回集合中的下一个元素。

#### 增强for循环
即 for each ，底层也是使用迭代器，使用for循环的格式简化了迭代器的书写。
目标只能是**集合**或者**数组**。
- 格式
    for(集合或者数组的数据类型  变量名 : 集合名/数组名 ){
   
        循环体;
    }

#### 泛型
未知的数据类型。
在创建集合对象时，如果不使用泛型：
- 默认为Object类型，可以存储任意类型的数据；
- 但是不安全，可能会引发异常。    
    
泛型可以用于
- 类
- 方法
- 接口

#### 数据结构
常见的数据结构：
##### 栈     
##### 队列
##### 链表
将一系列不连续的内存联系起来，合理利用碎片内存，动态的放置数据或者构建其他数据结构。链表中每个元素称为节点。
- 单向链表一个节点包括2各部分：数据源（存储数组），一个指针域（存储地址），最后一个指针指向NULL。
- 双向链表一个节点包括3各部分：数据源（存储数组），两个指针域（存储地址）。
- 循环链表是将单向或双向的首节点和末节点连接到一起。

   查询慢：链表中地址不连续，每次查询都要从头开始查询。
   增删快：增删操作对链表结构不影响。

##### 数组
    
   查询快：数组地址是连续的，通过首地址找到数组，通过索引查找元素。
   增删慢：数组长度是固定的，增删操作时，在堆内存中必须创建一个新数组，通过复制部分原数组实现增删，并销毁原数组。
    
##### 红黑树 
是一种自平衡的二叉查找树。
保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍。
- 节点是红色或者黑色；
- 根节点是黑色；
- 每个叶子结点都是黑色的空节点；
- 每个红色节点的两个子节点是黑色；
- 从任一节点到其每个叶子结点的所有路径都包含相同数目的黑色节点。


#### Debug快捷键

| f8 | 逐行执行程序 |
| :-: | :-: |
| f7 | 进入到方法内 |
| shift + f8 | 跳出方法 |
| f9 | 跳到下一个断点 |
| ctrl + f2 | 退出Debug模式 |
| Console | 切换到控制台 |

#### 异常
##### Throwable类
- Error：严重错误，无法处理；只能修改代码。
- Exception：编译期异常，可以处理纠正。

- 3个处理异常的方法
| getMessage() | 返回此throwable的简短描述 |
| :-: | :-: |
| toString() | 返回此throwable的详细描述 |
| printStackTrace() | JVM打印异常信息，最全面 |

##### throw关键字
- 写在方法内部；
- 可以用throw关键字在指定的方法中抛出指定的异常；
- 可以用于方法入参合法性的判断；
- 关键字后面创建的是RuntimeException或者是其子类对象，可以不处理，交给JVM打印异常；其它异常需要处理。
- 格式：throw new XXXException
#### 处理异常
- throws关键字
- try...catch
##### throws关键字
- throws关键字写在方法声明处；
- 关键字后面声明的异常必须是Exception或者是其子类；
- 如果调用了一个声明抛出异常的方法，就必须处理该异常；要么继续使用throws声明抛出，最终交给JVM；要么try...catch自己处理。

#### Thread

#### 多线程
##### 并发与并行
- 并发：多个事件在同一个时间段内发生；交替执行；
- 并行：多个事件同一时刻发生；同时执行；

##### 进程与线程
- 进程
是指内存中一个运行的应用程序，是系统运行程序的基本单位；一个应用程序可以同时运行多个进程；
- 线程
    属于进程，是进程中的一个执行单元，负责程序的执行；

##### 线程调度
- 分时调度
所有线程轮流使用CPU的使用权，时间平均分配；
- 抢占式调度
优先级高的线程优先使用CPU，优先级相同则随机选择；Java使用抢占式调度；

#### 解决线程安全问题
- 同步代码块
- 同步方法
- 锁机制

#### 线程池
容纳多个线程的容器，让线程可以反复使用，节省了重复创建线程的损耗。

#### Lambda
使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法；
格式：(参数)->{重写的方法体代码};

#### File类
- Windows用反斜杠：\ ； 使用反义符，所以要用双反斜杠：\\
- Linux用正斜杠：/；

| creatNewFile() | 创建新文件 |
| :-: | :-: |
| delete() | 删除文件或者文件夹 |
| mkdir() | 创建单级文件夹 |
| mkdirs() | 创建多级文件夹 |
| list() | 返回String数组，表示File中的所有文件或目录 |


#### IO流
##### 文件输入输出字节流
- FileInputStream
- FileOutputStream

##### 文件输入输出字符流
- FileReader
- FileWriter

##### 缓冲字节流
- BufferedInputStream
- BufferedOutputStream

##### 缓冲字符流
- BufferedReader
- BufferedWriter

##### 编码转换流
- InputStreamReader
- OutputStreamWriter

##### 序列化与反序列化流
###### 序列化
把对象保存到文件中；
静态变量不能被序列化；
被transient修饰的成员变量也不能序列化；
- ObjectOutputStream
- ObjectInputStream

#### flush()和close()
字符流中：
- flush():刷新缓冲区，流对象可以继续使用；
- close():刷新缓冲区，并且通知系统释放资源，关闭流对象。

#### Properties集合
Properties是一个双列集合，Key和Value默认是字符串；
唯一和IO流相结合的集合；Properties类表示一个持久的属性集；

- store():把集合中的临时数据，持久化写到硬盘中存储。
- load():读取硬盘中的键值对到集合中；

#### Stream流
流式编程思想；

- 延迟方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用；
- 终结方法：返回值类型不是Stream接口类型，不能链式调用。"eg.count()、forEach()"

- forEach()：函数参数是一个Consumer函数式接口，用来遍历流。
- filter(): 函数参数一个Predicate函数式接口，用来过滤流。
- map(): 参数是Function接口，用来转换数据类型，即映射。
- skip(): 跳过；
- concat(): 合并流；
- count(): 计数；
- limit(): 取流的前几位。

#### Junit单元测试
- Junit为白盒测试；
- 定义的测试方法可以独立运行；
- 测试类命名：“原类 + test”，测试方法命名：“原方法名 + test”。

**注解：**
- @Befor(): 初始化方法，用于资源申请等，该方法会优先执行；
- @After(): 释放资源方法，测试方法执行完后，会自动执行该方法；
- @Test():  定义测试方法。

**测试结果验证：**
```markdown
Assert.assertEquals(期望的结果，预算的结果)；
```


#### 反射Reflect
框架设计的灵魂。
- 框架：半成品软件。可以在框架的基础上开发，事半功倍。
- 反射：将类的各个组成部分封装为其他对象，这就是反射机制。

##### 获取Class对象的方式
- 1.Class.forName("全类名")：将字节码文件加载进内存，返回Class对象；
        - 多用于配置文件，将类名定义在配置文件中，读取文件，加载类。
* 2.类名.Class: 通过类名的属性class获取；
        - 多用于参数传递。
- 3.对象.getClass(): Object类定义了getClass()方法。
        - 用于获取对象的字节码。
        
**注意：** 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，三种方法获取的class对象都是同一个。

##### Class对象的功能

- 1.获取成员变量们
        - Field[] getFields(): 获取public的成员变量
        - Field getField(String name)：获取名为name的public的成员变量
    
        - Field[] getDeclaredFields(): 获取所有成员变量，不考虑修饰符
        - Field getDeclaredField(String name)
- 2.获取构造方法们
        - Constructor<?>[] getConstructors()
        - Constructor<?> getConstructor(类<?>... parameterType)
        
- 3.获取成员方法们
        - Method[] getMethods()
        - Method getMethod(String name,类<?>... parameterType)
        
- 4.获取类名
        - String getName()   
        
##### Field类：成员变量
- 1.设置值
        - void set(Object obj,Object value)
- 2.获取值
        - get(Object obj)
- 3.忽略访问权限修饰符的安全检查
        - setAccessible(true): 暴力反射，可以访问私有变量。
        
##### Constructor类：构造方法
- T newInstance(parameter)

##### Method类：成员方法对象
- 1.执行方法：
        - Object invoke(Object obj,Object ... args)                       
- 2.获取方法名称：
        - String getName  
        
#### 反射机制的应用
- 1.将需要创建的对象的全类名（包名+类名）、需要执行的方法定义在配置文件中；
- 2.在程序中加载和读取配置文件
- 3.使用反射技术加载类文件到内存中
- 4.创建对象
- 5.执行方法

#### 注解(Annotation)
本质上是一个接口，Javap反编译注解的class文件，可以发现注解默认继承了Annotation接口。

**作用：**
- 1.编写文档：通过代码里标识的注解生成官方DOC文档；
- 2.代码分析：通过代码里标识的注解对代码进行分析（利用反射）；
- 3.编译检查：编译器利用注解进行基本的编译检查 

**JDK预定义的常用注解**
- 1.@Override：检测该注解标注的方法是否继承自父类，重写方法时使用；
- 2.@Deprecated：该注解标注已过时的内容；
- 3.@SuppressWarning：压制警告。

#### 元注解
用于描述注解的注解；
在自定义注解时，写在注解前面，用于描述该注解。

- 1.**@Target：**描述注解能够作用的位置；
- 2.**@Retention：**描述注解被保留的阶段；
- 3.**@Documented：**描述注解是否被抽取到API文档中；
- 4.**@Inherited：**描述注解是否被子类继承。
       
       